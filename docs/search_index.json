[
["index.html", "Peroxide Guide 1 Prerequisites", " Peroxide Guide Axect 2019-03-05 1 Prerequisites Rust Peroxide "],
["quick.html", "2 Quick Start 2.1 Cargo.toml 2.2 Import all at once", " 2 Quick Start 2.1 Cargo.toml To use peroxide, you should edit Cargo.toml Current document version is corresponding to 0.8 peroxide = &quot;0.8&quot; 2.2 Import all at once You can import all functions &amp; structures at once extern crate peroxide; use peroxide::*; fn main() { //Some codes... } "],
["vector.html", "3 Vector 3.1 Print Vec&lt;f64&gt; 3.2 Syntactic sugar for Vec&lt;f64&gt; 3.3 From ranges to Vector 3.4 Vector Operation 3.5 Concatenation", " 3 Vector 3.1 Print Vec&lt;f64&gt; There are two ways to print vector Original way: print!(\"{:?}\", a); Peroxide way: a.print(); - Round to fourth digit fn main() { let a = vec![2f64.sqrt()]; a.print(); // [1.4142] } 3.2 Syntactic sugar for Vec&lt;f64&gt; There is useful macro for Vec&lt;f64&gt; For R, there is c # R a = c(1,2,3,4) For Peroxide, there is c! // Rust fn main() { let a = c!(1,2,3,4); } 3.3 From ranges to Vector For R, there is seq to declare sequence. # R a = seq(1, 4, 1) print(a) # [1] 1 2 3 4 For peroxide, there is seq to declare sequence. fn main() { let a = seq(1, 4, 1); a.print(); // [1, 2, 3, 4] } 3.4 Vector Operation There are some vector-wise operations add(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; sub(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; mul(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; div(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; dot(&amp;self, other: Vec&lt;f64&gt;) -&gt; f64 norm(&amp;self) -&gt; f64 fn main() { let a = c!(1,2,3,4); let b = c!(4,3,2,1); a.add(&amp;b).print(); a.sub(&amp;b).print(); a.mul(&amp;b).print(); a.div(&amp;b).print(); a.dot(&amp;b).print(); a.norm().print(); // [5, 5, 5, 5] // [-3, -1, 1, 3] // [4, 6, 6, 4] // [0.25, 0.6667, 1.5, 4] // 20 // 5.477225575051661 // sqrt(30) } And there are some useful operations too. pow(&amp;self, usize) -&gt; Vec&lt;f64&gt; powf(&amp;self, f64) -&gt; Vec&lt;f64&gt; sqrt(&amp;self) -&gt; Vec&lt;f64&gt; fn main() { let a = c!(1,2,3,4); a.pow(2).print(); a.powf(0.5).print(); a.sqrt().print(); // [1, 4, 9, 16] // [1, 1.4142, 1.7321, 2] // [1, 1.4142, 1.7321, 2] } 3.5 Concatenation There are two concatenation operations. cat(T, Vec&lt;T&gt;) -&gt; Vec&lt;f64&gt; concat(Vec&lt;T&gt;, Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; fn main() { let a = c!(1,2,3,4); cat(0f64, a.clone()).print(); // [0, 1, 2, 3, 4] let b = c!(5,6,7,8); concat(a, b).print(); // [1, 2, 3, 4, 5, 6, 7, 8] } "],
["matrix.html", "4 Matrix 4.1 Declare matrix 4.2 Basic Method for Matrix 4.3 Read &amp; Write 4.4 Concatenation 4.5 Matrix operations 4.6 Extract &amp; modify components", " 4 Matrix 4.1 Declare matrix You can declare matrix by various ways. R’s way - Default MATLAB’s way Python’s way Other macro 4.1.1 R’s way Description: Same as R - matrix(Vector, Row, Col, Shape) Type: matrix(Vec&lt;T&gt;, usize, usize, Shape) where T: std::convert::Into&lt;f64&gt; + Copy Shape: Enum for matrix shape - Row &amp; Col fn main() { let a = matrix(c!(1,2,3,4), 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 let b = matrix(c!(1,2,3,4), 2, 2, Col); b.print(); // c[0] c[1] // r[0] 1 3 // r[1] 2 4 } 4.1.2 MATLAB’s way Description: Similar to MATLAB (But should use &amp;str) Type: ml_matrix(&amp;str) fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.3 Python’s way Description: Declare matrix as vector of vectors. Type: py_matrix(Vec&lt;Vec&lt;T&gt;&gt;) where T: std::convert::Into&lt;f64&gt; + Copy fn main() { let a = py_matrix(vec![vec![1, 2], vec![3, 4]]); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.4 Other macro Description: R-like macro to declare matrix For R, # R a = matrix(1:4:1, 2, 2, Row) print(a) # [,1] [,2] # [1,] 1 2 # [2,] 3 4 For Peroxide, fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.2 Basic Method for Matrix There are some useful methods for Matrix row(&amp;self, index: usize) -&gt; Vec&lt;f64&gt; : Extract specific row as Vec&lt;f64&gt; col(&amp;self, index: usize) -&gt; Vec&lt;f64&gt; : Extract specific column as Vec&lt;f64&gt; diag(&amp;self) -&gt; Vec&lt;f64&gt;: Extract diagonal components as Vec&lt;f64&gt; swap(&amp;self, usize, usize, Shape) -&gt; Matrix: Swap two rows or columns subs_col(&amp;mut self, usize, Vec&lt;f64&gt;): Substitute column with Vec&lt;f64&gt; subs_row(&amp;mut self, usize, Vec&lt;f64&gt;): Substitute row with Vec&lt;f64&gt; fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.row(0).print(); // [1, 2] a.col(0).print(); // [1, 3] a.diag().print(); // [1, 4] a.swap(0, 1, Row).print(); // c[0] c[1] // r[0] 3 4 // r[1] 1 2 let mut b = ml_matrix(&quot;1 2;3 4&quot;); b.subs_col(0, c!(5, 6)); b.subs_row(1, c!(7, 8)); b.print(); // c[0] c[1] // r[0] 5 2 // r[1] 7 8 } 4.3 Read &amp; Write In peroxide, we can write matrix to csv. write(&amp;self, file_path: &amp;str): Write matrix to csv write_with_header(&amp;self, file_path, header: Vec&lt;&amp;str&gt;): Write with header fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); a.write(&quot;matrix.csv&quot;).expect(&quot;Can&#39;t write file&quot;); let b = ml_matrix(&quot;1 2; 3 4; 5 6&quot;); b.write_with_header(&quot;header.csv&quot;, vec![&quot;odd&quot;, &quot;even&quot;]) .expect(&quot;Can&#39;t write header file&quot;); } Also, you can read matrix from csv. Type: read(&amp;str, bool, char) -&gt; Result&lt;Matrix, Box&lt;Error&gt;&gt; Description: read(file_path, is_header, delimiter) fn main() { let a = read(&quot;matrix.csv&quot;, false, &#39;,&#39;) .expect(&quot;Can&#39;t read matrix.csv file&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.4 Concatenation There are two options to concatenate matrices. cbind: Concatenate two matrices by column direction. rbind: Concatenate two matrices by row direction. fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); let b = ml_matrix(&quot;5 6;7 8&quot;); cbind(a.clone(), b.clone()).print(); // c[0] c[1] c[2] c[3] // r[0] 1 2 5 7 // r[1] 3 4 6 8 rbind(a, b).print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 // r[2] 5 6 // r[3] 7 8 } 4.5 Matrix operations In peroxide, can use basic operations between matrices. I’ll show you by examples. fn main() { let a = matrix!(1;4;1, 2, 2, Row); (a.clone() + 1).print(); // -, *, / are also available // c[0] c[1] // r[0] 2 3 // r[1] 4 5 let b = matrix!(5;8;1, 2, 2, Row); (a.clone() + b.clone()).print(); // -, *, / are also available // c[0] c[1] // r[0] 6 8 // r[1] 10 12 (a.clone() % b.clone()).print(); // Matrix multiplication // c[0] c[1] // r[0] 19 22 // r[1] 43 50 } 4.6 Extract &amp; modify components In peroxide, matrix data is saved as linear structure. But you can use two-dimensional index to extract or modify components. fn main() { let mut a = matrix!(1;4;1, 2, 2, Row); a[(0,0)].print(); // 1 a[(0,0)] = 2f64; // Modify component a.print(); // c[0] c[1] // r[0] 2 2 // r[1] 3 4 } "],
["references.html", "References", " References "]
]
