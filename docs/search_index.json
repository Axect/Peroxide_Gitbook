[
["index.html", "Peroxide Guide 1 Prerequisites", " Peroxide Guide Axect 2019-06-27 1 Prerequisites Rust Peroxide "],
["quick.html", "2 Quick Start 2.1 Cargo.toml 2.2 Import all at once", " 2 Quick Start 2.1 Cargo.toml To use peroxide, you should edit Cargo.toml Current document version is corresponding to 0.10.0 peroxide = &quot;0.10&quot; 2.2 Import all at once You can import all functions &amp; structures at once extern crate peroxide; use peroxide::*; fn main() { //Some codes... } "],
["vector.html", "3 Vector 3.1 Print Vec&lt;f64&gt; 3.2 Syntactic sugar for Vec&lt;f64&gt; 3.3 From ranges to Vector 3.4 Vector Operation 3.5 Concatenation 3.6 Conversion to Matrix", " 3 Vector 3.1 Print Vec&lt;f64&gt; There are two ways to print vector Original way: print!(\"{:?}\", a); Peroxide way: a.print(); - Round-off to fourth digit fn main() { let a = vec![2f64.sqrt()]; a.print(); // [1.4142] } 3.2 Syntactic sugar for Vec&lt;f64&gt; There is useful macro for Vec&lt;f64&gt; For R, there is c # R a = c(1,2,3,4) For Peroxide, there is c! // Rust fn main() { let a = c!(1,2,3,4); } 3.3 From ranges to Vector For R, there is seq to declare sequence. # R a = seq(1, 4, 1) print(a) # [1] 1 2 3 4 For peroxide, there is seq to declare sequence. fn main() { let a = seq(1, 4, 1); a.print(); // [1, 2, 3, 4] } 3.4 Vector Operation There are some vector-wise operations add(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; sub(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; mul(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; div(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; dot(&amp;self, other: Vec&lt;f64&gt;) -&gt; f64 norm(&amp;self) -&gt; f64 fn main() { let a = c!(1,2,3,4); let b = c!(4,3,2,1); a.add(&amp;b).print(); a.sub(&amp;b).print(); a.mul(&amp;b).print(); a.div(&amp;b).print(); a.dot(&amp;b).print(); a.norm().print(); // [5, 5, 5, 5] // [-3, -1, 1, 3] // [4, 6, 6, 4] // [0.25, 0.6667, 1.5, 4] // 20 // 5.477225575051661 // sqrt(30) } And there are some useful operations too. pow(&amp;self, usize) -&gt; Vec&lt;f64&gt; powf(&amp;self, f64) -&gt; Vec&lt;f64&gt; sqrt(&amp;self) -&gt; Vec&lt;f64&gt; fn main() { let a = c!(1,2,3,4); a.pow(2).print(); a.powf(0.5).print(); a.sqrt().print(); // [1, 4, 9, 16] // [1, 1.4142, 1.7321, 2] // [1, 1.4142, 1.7321, 2] } 3.5 Concatenation There are two concatenation operations. cat(T, Vec&lt;T&gt;) -&gt; Vec&lt;f64&gt; concat(Vec&lt;T&gt;, Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; fn main() { let a = c!(1,2,3,4); cat(0f64, a.clone()).print(); // [0, 1, 2, 3, 4] let b = c!(5,6,7,8); concat(a, b).print(); // [1, 2, 3, 4, 5, 6, 7, 8] } 3.6 Conversion to Matrix There are two ways to convert vector to matrix. to_matrix(&amp;self) -&gt; Matrix : Vector to column matrix transpose(&amp;self) -&gt; Matrix : Vector to row matrix fn main() { let a = c!(1,2,3,4); let m_col = matrix(c!(1,2,3,4), 4, 1, Col); // (4,1) Matrix assert_eq!(a.to_matrix(), m_col); let m_row = matrix(c!(1,2,3,4), 1, 4, Row); // (1,4) Matrix assert_eq!(a.transpose(), m_row); } "],
["matrix.html", "4 Matrix 4.1 Declare matrix 4.2 Basic Method for Matrix 4.3 Read &amp; Write 4.4 Concatenation 4.5 Matrix operations 4.6 Extract &amp; modify components 4.7 Conversion to vector 4.8 Useful constructor", " 4 Matrix 4.1 Declare matrix You can declare matrix by various ways. R’s way - Default MATLAB’s way Python’s way Other macro 4.1.1 R’s way Description: Same as R - matrix(Vector, Row, Col, Shape) Type: matrix(Vec&lt;T&gt;, usize, usize, Shape) where T: std::convert::Into&lt;f64&gt; + Copy Shape: Enum for matrix shape - Row &amp; Col fn main() { let a = matrix(c!(1,2,3,4), 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 let b = matrix(c!(1,2,3,4), 2, 2, Col); b.print(); // c[0] c[1] // r[0] 1 3 // r[1] 2 4 } 4.1.2 MATLAB’s way Description: Similar to MATLAB (But should use &amp;str) Type: ml_matrix(&amp;str) fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.3 Python’s way Description: Declare matrix as vector of vectors. Type: py_matrix(Vec&lt;Vec&lt;T&gt;&gt;) where T: std::convert::Into&lt;f64&gt; + Copy fn main() { let a = py_matrix(vec![vec![1, 2], vec![3, 4]]); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.4 Other macro Description: R-like macro to declare matrix For R, # R a = matrix(1:4:1, 2, 2, Row) print(a) # [,1] [,2] # [1,] 1 2 # [2,] 3 4 For Peroxide, fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.2 Basic Method for Matrix There are some useful methods for Matrix row(&amp;self, index: usize) -&gt; Vec&lt;f64&gt; : Extract specific row as Vec&lt;f64&gt; col(&amp;self, index: usize) -&gt; Vec&lt;f64&gt; : Extract specific column as Vec&lt;f64&gt; diag(&amp;self) -&gt; Vec&lt;f64&gt;: Extract diagonal components as Vec&lt;f64&gt; swap(&amp;self, usize, usize, Shape) -&gt; Matrix: Swap two rows or columns subs_col(&amp;mut self, usize, Vec&lt;f64&gt;): Substitute column with Vec&lt;f64&gt; subs_row(&amp;mut self, usize, Vec&lt;f64&gt;): Substitute row with Vec&lt;f64&gt; fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.row(0).print(); // [1, 2] a.col(0).print(); // [1, 3] a.diag().print(); // [1, 4] a.swap(0, 1, Row).print(); // c[0] c[1] // r[0] 3 4 // r[1] 1 2 let mut b = ml_matrix(&quot;1 2;3 4&quot;); b.subs_col(0, c!(5, 6)); b.subs_row(1, c!(7, 8)); b.print(); // c[0] c[1] // r[0] 5 2 // r[1] 7 8 } 4.3 Read &amp; Write In peroxide, we can write matrix to csv or pickle. 4.3.1 CSV (Legacy) write(&amp;self, file_path: &amp;str): Write matrix to csv write_with_header(&amp;self, file_path, header: Vec&lt;&amp;str&gt;): Write with header fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); a.write(&quot;matrix.csv&quot;).expect(&quot;Can&#39;t write file&quot;); let b = ml_matrix(&quot;1 2; 3 4; 5 6&quot;); b.write_with_header(&quot;header.csv&quot;, vec![&quot;odd&quot;, &quot;even&quot;]) .expect(&quot;Can&#39;t write header file&quot;); } Also, you can read matrix from csv. Type: read(&amp;str, bool, char) -&gt; Result&lt;Matrix, Box&lt;Error&gt;&gt; Description: read(file_path, is_header, delimiter) fn main() { let a = read(&quot;matrix.csv&quot;, false, &#39;,&#39;) .expect(&quot;Can&#39;t read matrix.csv file&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.3.2 Pickle (Export as python object) SimpleWriter : Struct to write pickle Necessary method set_path : Set path insert_matrix or insert_vector write_pickle : Must be at last Optional method set_round_level : Set round-off level insert_header : Insert header fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); let v = c!(1,2,3,4); let mut wrt = SimpleWriter::new(); wrt.set_path(&quot;data/sample.pickle&quot;) .insert_matrix(a) .insert_vector(v) .set_round_level(4) .write_pickle(); } 4.4 Concatenation There are two options to concatenate matrices. cbind: Concatenate two matrices by column direction. rbind: Concatenate two matrices by row direction. fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); let b = ml_matrix(&quot;5 6;7 8&quot;); cbind(a.clone(), b.clone()).print(); // c[0] c[1] c[2] c[3] // r[0] 1 2 5 7 // r[1] 3 4 6 8 rbind(a, b).print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 // r[2] 5 6 // r[3] 7 8 } 4.5 Matrix operations In peroxide, can use basic operations between matrices. I’ll show you by examples. fn main() { let a = matrix!(1;4;1, 2, 2, Row); (a.clone() + 1).print(); // -, *, / are also available // c[0] c[1] // r[0] 2 3 // r[1] 4 5 let b = matrix!(5;8;1, 2, 2, Row); (a.clone() + b.clone()).print(); // - is also available // c[0] c[1] // r[0] 6 8 // r[1] 10 12 (a.clone() * b.clone()).print(); // Matrix multiplication // c[0] c[1] // r[0] 19 22 // r[1] 43 50 } clone is too annoying - We can use reference operations! fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); let b = ml_matrix(&quot;5 6;7 8&quot;); (&amp;a + 1).print(); (&amp;a + &amp;b).print(); (&amp;a - &amp;b).print(); (&amp;a * &amp;b).print(); } 4.6 Extract &amp; modify components In peroxide, matrix data is saved as linear structure. But you can use two-dimensional index to extract or modify components. fn main() { let mut a = matrix!(1;4;1, 2, 2, Row); a[(0,0)].print(); // 1 a[(0,0)] = 2f64; // Modify component a.print(); // c[0] c[1] // r[0] 2 2 // r[1] 3 4 } 4.7 Conversion to vector Just use row or col method (I already showed at Basic method section). fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.row(0).print(); // [1, 2] } 4.8 Useful constructor zeros(usize, usize): Construct matrix which elements are all zero eye(usize): Identity matrix rand(usize, usize): Construct random uniform matrix (from 0 to 1) fn main() { let a = zeros(2, 2); assert_eq!(a, ml_matrix(&quot;0 0;0 0&quot;)); let b = eye(2); assert_eq!(b, ml_matrix(&quot;1 0;0 1&quot;)); let c = rand(2, 2); c.print(); // Random 2x2 matrix } "],
["linear.html", "5 Linear Algebra 5.1 Transpose 5.2 LU Decomposition 5.3 Determinant 5.4 Inverse matrix 5.5 Moore-Penrose Pseudo Inverse", " 5 Linear Algebra 5.1 Transpose Caution: Transpose does not consume the original value. fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.transpose().print(); // Or you can use shorter one a.t().print(); // c[0] c[1] // r[0] 1 3 // r[1] 2 4 } 5.2 LU Decomposition Peroxide uses complete pivoting for LU decomposition - Very stable Since there are lots of causes to generate error, you should use Option lu returns Option&lt;PQLU&gt; PQLU has four field - p, q, l , u p means row permutations q means column permutations l means lower triangular matrix u menas upper triangular matrix The structure of PQLU is as follows: #[derive(Debug, Clone)] pub struct PQLU { pub p: Perms, pub q: Perms, pub l: Matrix, pub u: Matrix, } pub type Perms = Vec&lt;(usize, usize)&gt;; Example of LU decomposition: fn main() { let a = matrix(c!(1,2,3,4), 2, 2, Row); let pqlu = a.lu().unwrap(); // unwrap because of Option let (p,q,l,u) = (pqlu.p, pqlu.q, pqlu.l, pqlu.u); assert_eq!(p, vec![(0,1)]); // swap 0 &amp; 1 (Row) assert_eq!(q, vec![(0,1)]); // swap 0 &amp; 1 (Col) assert_eq!(l, matrix(c!(1,0,0.5,1),2,2,Row)); // c[0] c[1] // r[0] 1 0 // r[1] 0.5 1 assert_eq!(u, matrix(c!(4,3,0,-0.5),2,2,Row)); // c[0] c[1] // r[0] 4 3 // r[1] 0 -0.5 } 5.3 Determinant Peroxide uses LU decomposition to obtain determinant (\\(\\mathcal{O}(n^3)\\)) fn main() { let a = matrix!(1;4;1, 2, 2, Row); assert_eq!(a.det(), -2f64); } 5.4 Inverse matrix Peroxide uses LU decomposition to obtain inverse matrix. It needs two sub functions - inv_l, inv_u For inverse of L, U, I use block partitioning. For example, for lower triangular matrix : \\[\\begin{aligned} L &amp;= \\begin{pmatrix} L_1 &amp; \\mathbf{0} \\\\ L_2 &amp; L_3 \\end{pmatrix} \\\\ L^{-1} &amp;= \\begin{pmatrix} L_1^{-1} &amp; \\mathbf{0} \\\\ -L_3^{-1}L_2 L_1^{-1} &amp; L_3^{-1} \\end{pmatrix} \\end{aligned} \\] fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.inv().unwrap().print(); // c[0] c[1] // r[0] -2 1 // r[1] 1.5 -0.5 } 5.5 Moore-Penrose Pseudo Inverse \\(X^\\dagger = \\left(X^T X\\right)^{-1} X\\) fn main() { let a = matrix!(1;4;1, 2, 2, Row); let pinv_a = a.psudo_inv().unwrap(); let inv_a = a.inv().unwrap(); assert_eq!(inv_a, pinv_a); // Nearly equal (not actually equal) } // PartialEq implements impl PartialEq for Matrix { fn eq(&amp;self, other: &amp;Matrix) -&gt; bool { if self.shape == other.shape { self.data.clone() .into_iter() .zip(other.data.clone()) .all(|(x, y)| nearly_eq(x,y)) &amp;&amp; self.row == other.row } else { self.eq(&amp;other.change_shape()) } } } "],
["functional.html", "6 Functional Programming 6.1 FP for Vector 6.2 FP for Matrix", " 6 Functional Programming 6.1 FP for Vector There are some functional programming tools for Vec&lt;f64&gt; pub trait FPVector { type Scalar; fn fmap&lt;F&gt;(&amp;self, f: F) -&gt; Self where F: Fn(Self::Scalar) -&gt; Self::Scalar; fn reduce&lt;F, T&gt;(&amp;self, init: T, f: F) -&gt; Self::Scalar where F: Fn(Self::Scalar, Self::Scalar) -&gt; Self::Scalar, T: convert::Into&lt;Self::Scalar&gt;; fn zip_with&lt;F&gt;(&amp;self, f: F, other: &amp;Self) -&gt; Self where F: Fn(Self::Scalar, Self::Scalar) -&gt; Self::Scalar; fn filter&lt;F&gt;(&amp;self, f: F) -&gt; Self where F: Fn(Self::Scalar) -&gt; bool; fn take(&amp;self, n: usize) -&gt; Self; fn skip(&amp;self, n: usize) -&gt; Self; } 6.1.1 fmap fmap is syntactic sugar for map But different to original map - Only f64 -&gt; f64 allowed. fn main() { let a = c!(1,2,3,4); // Original rust a.clone() .into_iter() .map(|x| x + 1f64) .collect::&lt;Vec&lt;f64&gt;&gt;() .print(); // [2, 3, 4, 5] // fmap in Peroxide a.fmap(|x| x + 1f64).print(); // [2, 3, 4, 5] } 6.1.2 reduce reduce is syntactic sugar for fold fn main() { let a = c!(1,2,3,4); // Original rust a.clone() .into_iter() .fold(0f64, |x, y| x + y) .print(); // 10 // reduce in Peroxide a.reduce(0f64, |x, y| x + y).print(); // 10 } 6.1.3 zip_with zip_with is composed of zip &amp; map fn main() { let a = c!(1,2,3,4); let b = c!(5,6,7,8); // Original rust a.clone() .into_iter() .zip(&amp;b) .map(|(x, y)| x + *y) .collect::&lt;Vec&lt;f64&gt;&gt;().print(); // [6, 8, 10, 12] // zip_with in Peroxide a.zip_with(|x, y| x + y, &amp;b).print(); // [6, 8, 10, 12] } 6.1.4 filter filter is just syntactic sugar for filter fn main() { let a = c!(1,2,3,4); a.filter(|x| x &gt; 2f64).print(); // [3, 4] } 6.1.5 take &amp; skip take is syntactic sugar for take fn main() { let a = c!(1,2,3,4); a.take(2).print(); // [1, 2] } skip is syntactic sugar for skip fn main() { let a = c!(1,2,3,4); a.skip(2).print(); // [3, 4] } 6.2 FP for Matrix Similar to FPVector pub trait FP { fn take(&amp;self, n: usize, shape: Shape) -&gt; Matrix; fn skip(&amp;self, n: usize, shape: Shape) -&gt; Matrix; fn fmap&lt;F&gt;(&amp;self, f: F) -&gt; Matrix where F: Fn(f64) -&gt; f64; fn reduce&lt;F, T&gt;(&amp;self, init: T, f: F) -&gt; f64 where F: Fn(f64, f64) -&gt; f64, T: convert::Into&lt;f64&gt;; fn zip_with&lt;F&gt;(&amp;self, f: F, other: &amp;Matrix) -&gt; Matrix where F: Fn(f64, f64) -&gt; f64; } Above functions play same roles as FPVector "],
["statistics.html", "7 Statistics 7.1 Statistics trait 7.2 Simple Random Number Generator 7.3 Probability Distribution", " 7 Statistics 7.1 Statistics trait To make generic code, there is Statistics trait mean: just mean var : variance sd : standard deviation (R-like notation) cov : covariance cor : correlation coefficient pub trait Statistics { type Array; type Value; fn mean(&amp;self) -&gt; Self::Value; fn var(&amp;self) -&gt; Self::Value; fn sd(&amp;self) -&gt; Self::Value; fn cov(&amp;self) -&gt; Self::Array; fn cor(&amp;self) -&gt; Self::Array; } 7.1.1 For Vec&lt;f64&gt; Caution: For Vec&lt;f64&gt;, cov &amp; cor are unimplemented (those for Matrix) fn main() { let a = c!(1,2,3,4,5); a.mean().print(); // 3 a.var().print(); // 2.5 a.sd().print(); // 1.5811388300841898 } But there are other functions to calculate cov &amp; cor fn main() { let v1 = c!(1,2,3); let v2 = c!(3,2,1); cov(&amp;v1, &amp;v2).print(); // -0.9999999999999998 cor(&amp;v1, &amp;v2).print(); // -0.9999999999999993 } 7.1.2 For Matrix For Matrix, mean, var, sd means column operations cov means covariance matrix &amp; cor means also correlation coefficient matrix fn main() { let m = matrix(c!(1,2,3,3,2,1), 3, 2, Col); m.mean().print(); // [2, 2] m.var().print(); // [1.0000, 1.0000] m.sd().print(); // [1.0000, 1.0000] m.cov().print(); // c[0] c[1] // r[0] 1.0000 -1.0000 // r[1] -1.0000 1.0000 m.cor().print(); // c[0] c[1] // r[0] 1 -1.0000 // r[1] -1.0000 1 } 7.2 Simple Random Number Generator Peroxide uses external rand crate to generate random number extern crate rand; use self::rand::prelude::*; fn main() { let mut rng = thread_rng(); let a = rng.gen_range(0f64, 1f64); // Generate random f64 number ranges from 0 to 1 } To want more detailed explanation, see rand crate 7.3 Probability Distribution There are some famous pdf in Peroxide (not checked pdfs will be implemented soon) Bernoulli Beta Dirichlet Gamma Normal Student’s t Uniform Wishart There are two enums to represent probability distribution OPDist&lt;T&gt; : One parameter distribution (Bernoulli) TPDist&lt;T&gt; : Two parameter distribution (Uniform, Normal, Beta, Gamma) T: PartialOrd + SampleUniform + Copy + Into&lt;f64&gt; There are some traits for pdf RNG trait - extract sample &amp; calculate pdf Statistics trait - already shown above 7.3.1 RNG trait RNG trait is composed of two fields sample: Extract samples pdf : Calculate pdf value at specific point pub trait RNG { /// Extract samples of distributions fn sample(&amp;self, n: usize) -&gt; Vec&lt;f64&gt;; /// Probability Distribution Function /// /// # Type /// `f64 -&gt; f64` fn pdf&lt;S: PartialOrd + SampleUniform + Copy + Into&lt;f64&gt;&gt;(&amp;self, x: S) -&gt; f64; } 7.3.2 Bernoulli Distribution Definition \\[\\text{Bern}(x | \\mu) = \\mu^x (1-\\mu)^{1-x}\\] Representative value Mean: \\(\\mu\\) Var : \\(\\mu(1 - \\mu)\\) In peroxide, to generate \\(\\text{Bern}(x | \\mu)\\), use simple algorithm Generate \\(U \\sim \\text{Unif}(0, 1)\\) If \\(U \\leq \\mu\\), then \\(X = 1\\) else \\(X = 0\\) Usage is very simple fn main() { let b = Bernoulli(0.1); // Bern(x | 0.1) b.sample(100).print(); // Generate 100 samples b.pdf(0).print(); // 0.9 b.mean().print(); // 0.1 b.var().print(); // 0.09 (approximately) b.sd().print(); // 0.3 (approximately) } 7.3.3 Uniform Distribution Definition \\[\\text{Unif}(x | a, b) = \\begin{cases} \\frac{1}{b - a} &amp; x \\in [a,b]\\\\ 0 &amp; \\text{otherwise} \\end{cases}\\] Representative value Mean: \\(\\frac{a + b}{2}\\) Var : \\(\\frac{1}{12}(b-a)^2\\) To generate uniform random number, Peroxide uses rand crate fn main() { // Uniform(start, end) let a = Uniform(0, 1); a.sample(100).print(); a.pdf(0.2).print(); a.mean().print(); a.var().print(); a.sd().print(); } 7.3.4 Normal Distribution Definition \\[\\mathcal{N}(x | \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\exp{\\left( - \\frac{(x - \\mu)^2}{2\\sigma^2}\\right)}\\] Representative value Mean: \\(\\mu\\) Var: \\(\\sigma^2\\) To generate normal random number, there are two famous algorithms Marsaglia-Polar method Ziggurat algorithm In peroxide, main algorithm is Ziggurat - most efficient algorithm to generate random normal samples. Code is based on a C implementation by Jochen Voss. fn main() { // Normal(mean, std) let a = Normal(0, 1); // Standard normal a.sample(100).print(); a.pdf(0).print(); // Maximum probability a.mean().print(); a.var().print(); a.sd().print(); } 7.3.5 Beta Distribution 7.3.6 Gamma Distribution "],
["ad.html", "8 Automatic Differentiation 8.1 Dual number system 8.2 Hyper dual number system 8.3 Real trait", " 8 Automatic Differentiation 8.1 Dual number system Dual is structure for AD value(&amp;self) -&gt; f64 : Value slope(&amp;self) -&gt; f64 : Slope (value of derivatives) extract(&amp;self) -&gt; (f64,f64) : Extract both Constructor for Dual Dual::new(T, T) dual(T, T) Implemented Operations (Real trait is implemented) Add, Sub, Mul, Div sin, cos, tan asin, acos, atan sinh, cosh, tanh asinh, acosh, atanh sin_cos exp, ln, log, log2, log10 powi, powf, sqrt fn main() { let x = dual(1, 1); // x at x = 1 (x.clone() + x.clone()).print(); // dual(2, 2) (x.clone() - x.clone()).print(); // dual(0, 0) (x.clone() * x.clone()).print(); // dual(1, 2) (x.clone() / x.clone()).print(); // dual(1, 0) x.sin().print(); x.cos().print(); x.exp().print(); x.ln().print(); x.powi(2).print(); // same as x * x } After ver 0.10.1, you can use reference operations fn main() { let x = dual(1,1); (&amp;x + &amp;x).print(); (&amp;x - &amp;x).print(); // and etc. } 8.2 Hyper dual number system HyperDual is structure for 2nd order AD value(&amp;self) -&gt; f64 slope(&amp;self) -&gt; f64 accel(&amp;self) -&gt; f64 There are two constructors HyperDual::new(T, T, T) hyper_dual(T, T, T) fn main() { let x = hyper_dual(1, 1, 0); // x at x = 1 (x.clone() + x.clone()).print(); // hyper_dual(2, 2, 0) (x.clone() * x.clone()).print(); // hyper_dual(1, 2, 2) // and etc. } Also, after 0.10.1, you can use reference ops. fn main() { let x = hyper_dual(1,1,0); (&amp;x + &amp;x).print(); (&amp;x * &amp;x).print(); // and etc. } 8.3 Real trait Real is a trait for binding f64, Dual, HyperDual Real requires PowOps, TrigOps, ExpLogOps &amp; std::Ops&lt;Self&gt; &amp; std::Ops&lt;f64&gt; fn main() { let x_f64 = 2f64; let x_dual = dual(2,1); let x_hyper = hyper_dual(2, 1, 0); f(x_f64).print(); f(x_dual).print(); f(x_hyper).print(); } fn f&lt;T: Real&gt;(x: T) -&gt; T { return x.powi(2) } "],
["ode.html", "9 Ordinary Differential Equation 9.1 Introduce ODE Trait &amp; Structure 9.2 Example", " 9 Ordinary Differential Equation 9.1 Introduce ODE Trait &amp; Structure 9.1.1 ODE Trait ODE structures are divided by two kinds ExplicitODE ImplicitODE ODE trait is given as pub trait ODE { type Records; type Vector; type Param; type ODEMethod; fn mut_update(&amp;mut self); fn integrate(&amp;mut self) -&gt; Self::Records; fn set_initial_condition&lt;T: Real&gt;(&amp;mut self, init: State&lt;T&gt;) -&gt; &amp;mut Self; fn set_boundary_condition&lt;T: Real&gt;( &amp;mut self, bound1: (State&lt;T&gt;, BoundaryCondition), bound2: (State&lt;T&gt;, BoundaryCondition), ) -&gt; &amp;mut Self; fn set_step_size(&amp;mut self, dt: f64) -&gt; &amp;mut Self; fn set_method(&amp;mut self, method: Self::ODEMethod) -&gt; &amp;mut Self; fn set_stop_condition(&amp;mut self, f: fn(&amp;Self) -&gt; bool) -&gt; &amp;mut Self; fn set_times(&amp;mut self, n: usize) -&gt; &amp;mut Self; fn check_enough(&amp;self) -&gt; bool; } Records : The type to save results of ODE. Usually Matrix is used. Vector : Vector can be below things. Vec&lt;f64&gt; : Used for ExplicitODE Vec&lt;Dual&gt; : Used for ImplicitODE Param : Also it can be f64 or Dual ODEMethod : Method for solving ODE ExMethod : Explicit method Euler : Euler first order RK4 : Runge Kutta 4th order ImMethod : Implicit method (to be implemented) BDF : Backward Euler 1st order GL4 : Gauss Legendre 4th order 9.1.2 State&lt;T&gt; structure To use ODE trait, you should understand State&lt;T&gt; first. #[derive(Debug, Clone, Default)] pub struct State&lt;T: Real&gt; { pub param: T, pub value: Vec&lt;T&gt;, pub deriv: Vec&lt;T&gt;, } T can be f64 or Dual param is parameter for ODE. Usually it is represented by time. value is value of each node. deriv is value of derivative of each node. For example, \\[ \\frac{dy_n}{dt} = f(t, y_n) \\] \\(t\\) is param \\(y_n\\) is value \\(f(t,y_n)\\) is deriv Methods for State&lt;T&gt; are as follows. to_f64(&amp;self) -&gt; State&lt;f64&gt; to_dual(&amp;self) -&gt; State&lt;Dual&gt; new(T, Vec&lt;T&gt;, Vec&lt;T&gt;) -&gt; Self 9.1.3 ExplicitODE struct ExplicitODE is given as follow : #[derive(Clone)] pub struct ExplicitODE { state: State&lt;f64&gt;, func: fn(&amp;mut State&lt;f64&gt;), step_size: f64, method: ExMethod, init_cond: State&lt;f64&gt;, bound_cond1: (State&lt;f64&gt;, BoundaryCondition), bound_cond2: (State&lt;f64&gt;, BoundaryCondition), stop_cond: fn(&amp;Self) -&gt; bool, times: usize, to_use: HashMap&lt;ToUse, bool&gt;, } state : Current param, value, derivative func : Function to update state init_cond : Initial condition bound_cond1 : If boundary problem, then first boundary condition bound_cond2 : second boundary condition stop_cond : Stop condition (stop before times) times : How many times do you want to update? to_use : Just check whether information is enough 9.2 Example 9.2.1 Lorenz Butterfly extern crate peroxide; use peroxide::*; fn main() { // ========================================= // Declare ODE // ========================================= let mut ex_test = ExplicitODE::new(f); let init_state: State&lt;f64&gt; = State::new( 0.0, vec![10.0, 1.0, 1.0], vec![0.0, 0.0, 0.0], ); ex_test .set_initial_condition(init_state) .set_method(ExMethod::Euler) .set_step_size(0.01f64) .set_times(10000); let mut ex_test2 = ex_test.clone(); ex_test2.set_method(ExMethod::RK4); // ========================================= // Save results // ========================================= let results = ex_test.integrate(); let results2 = ex_test2.integrate(); // ========================================= // Write results to pickle // ========================================= let mut wt = SimpleWriter::new(); wt .set_path(&quot;example_data/lorenz.pickle&quot;) .insert_matrix(results) .insert_matrix(results2) .write_pickle(); } fn f(st: &amp;mut State&lt;f64&gt;) { let x = &amp;st.value; let dx = &amp;mut st.deriv; dx[0] = 10f64 * (x[1] - x[0]); dx[1] = 28f64 * x[0] - x[1] - x[0] * x[2]; dx[2] = -8f64/3f64 * x[2] + x[0] * x[1]; } If plotting pickle data with python, then Lorenz with Euler Lorenz with RK4 9.2.2 Simple 1D Runge-Kutta \\[\\begin{gathered} \\frac{dy}{dx} = \\frac{5x^2 - y}{e^{x+y}} \\\\ y(0) = 1 \\end{gathered}\\] extern crate peroxide; use peroxide::*; fn main() { let init_state = State::&lt;f64&gt;::new(0f64, c!(1), c!(0)); let mut ode_solver = ExplicitODE::new(test_fn); ode_solver .set_method(ExMethod::RK4) .set_initial_condition(init_state) .set_step_size(0.01) .set_times(1000); let result = ode_solver.integrate(); let mut st = SimpleWriter::new(); st.set_path(&quot;example_data/rk4_test.pickle&quot;) .insert_matrix(result) .write_pickle(); } fn test_fn(st: &amp;mut State&lt;f64&gt;) { let x = st.param; let y = &amp;st.value; let dy = &amp;mut st.deriv; dy[0] = (5f64*x.powi(2) - y[0]) / (x + y[0]).exp(); } "],
["references.html", "References", " References "]
]
