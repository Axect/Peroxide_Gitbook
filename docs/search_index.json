[
["index.html", "Peroxide Guide 1 Prerequisites", " Peroxide Guide Axect 2019-03-03 1 Prerequisites Rust Peroxide "],
["quick.html", "2 Quick Start 2.1 Cargo.toml 2.2 Import all at once", " 2 Quick Start 2.1 Cargo.toml To use peroxide, you should edit Cargo.toml peroxide = &quot;0.8.5&quot; 2.2 Import all at once You can import all functions &amp; structures at once extern crate peroxide; use peroxide::*; fn main() { //Some codes... } "],
["vector.html", "3 Vector 3.1 Print Vec&lt;f64&gt; 3.2 Syntactic sugar for Vec&lt;f64&gt; 3.3 From ranges to Vector 3.4 Vector Operation", " 3 Vector 3.1 Print Vec&lt;f64&gt; There are two ways to print vector Original way: print!(\"{:?}\", a); Peroxide way: a.print(); - Round to fourth digit fn main() { let a = vec![2f64.sqrt()]; a.print(); // [1.4142] } 3.2 Syntactic sugar for Vec&lt;f64&gt; There is useful macro for Vec&lt;f64&gt; For R, there is c # R a = c(1,2,3,4) For Peroxide, there is c! // Rust fn main() { let a = c!(1,2,3,4); } 3.3 From ranges to Vector For R, there is seq to declare sequence. # R a = seq(1, 4, 1) print(a) # [1] 1 2 3 4 For peroxide, there is seq to declare sequence. fn main() { let a = seq(1, 4, 1); a.print(); // [1, 2, 3, 4] } 3.4 Vector Operation There are some vector-wise operations add(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; sub(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; mul(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; div(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; dot(&amp;self, other: Vec&lt;f64&gt;) -&gt; f64 norm(&amp;self) -&gt; f64 fn main() { let a = c!(1,2,3,4); let b = c!(4,3,2,1); a.add(&amp;b).print(); a.sub(&amp;b).print(); a.mul(&amp;b).print(); a.div(&amp;b).print(); a.dot(&amp;b).print(); a.norm().print(); // [5, 5, 5, 5] // [-3, -1, 1, 3] // [4, 6, 6, 4] // [0.25, 0.6667, 1.5, 4] // 20 // 5.477225575051661 // sqrt(30) } And there are some useful operations too. pow(&amp;self, usize) -&gt; Vec&lt;f64&gt; powf(&amp;self, f64) -&gt; Vec&lt;f64&gt; sqrt(&amp;self) -&gt; Vec&lt;f64&gt; fn main() { let a = c!(1,2,3,4); a.pow(2).print(); a.powf(0.5).print(); a.sqrt().print(); // [1, 4, 9, 16] // [1, 1.4142, 1.7321, 2] // [1, 1.4142, 1.7321, 2] } "],
["matrix.html", "4 Matrix 4.1 Declare matrix", " 4 Matrix 4.1 Declare matrix You can declare matrix by various ways. R’s way - Default MATLAB’s way Python’s way Other macro 4.1.1 R’s way Description: Same as R - matrix(Vector, Row, Col, Shape) Type: matrix(Vec&lt;T&gt;, usize, usize, Shape) where T: std::convert::Into&lt;f64&gt; + Copy Shape: Enum for matrix shape - Row &amp; Col fn main() { let a = matrix(c!(1,2,3,4), 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 let b = matrix(c!(1,2,3,4), 2, 2, Col); b.print(); // c[0] c[1] // r[0] 1 3 // r[1] 2 4 } 4.1.2 MATLAB’s way Description: Similar to MATLAB (But should use &amp;str) Type: ml_matrix(&amp;str) fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.3 Python’s way Description: Declare matrix as vector of vectors. Type: py_matrix(Vec&lt;Vec&lt;T&gt;&gt;) where T: std::convert::Into&lt;f64&gt; + Copy fn main() { let a = py_matrix(vec![vec![1, 2], vec![3, 4]]); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.4 Other macro Description: R-like macro to declare matrix For R, # R a = matrix(1:4:1, 2, 2, Row) print(a) # [,1] [,2] # [1,] 1 2 # [2,] 3 4 For Peroxide, fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } "],
["references.html", "References", " References "]
]
