[
["index.html", "Peroxide Guide 1 Prerequisites", " Peroxide Guide Axect 2019-03-08 1 Prerequisites Rust Peroxide "],
["quick.html", "2 Quick Start 2.1 Cargo.toml 2.2 Import all at once", " 2 Quick Start 2.1 Cargo.toml To use peroxide, you should edit Cargo.toml Current document version is corresponding to 0.8 peroxide = &quot;0.8&quot; 2.2 Import all at once You can import all functions &amp; structures at once extern crate peroxide; use peroxide::*; fn main() { //Some codes... } "],
["vector.html", "3 Vector 3.1 Print Vec&lt;f64&gt; 3.2 Syntactic sugar for Vec&lt;f64&gt; 3.3 From ranges to Vector 3.4 Vector Operation 3.5 Concatenation", " 3 Vector 3.1 Print Vec&lt;f64&gt; There are two ways to print vector Original way: print!(\"{:?}\", a); Peroxide way: a.print(); - Round-off to fourth digit fn main() { let a = vec![2f64.sqrt()]; a.print(); // [1.4142] } 3.2 Syntactic sugar for Vec&lt;f64&gt; There is useful macro for Vec&lt;f64&gt; For R, there is c # R a = c(1,2,3,4) For Peroxide, there is c! // Rust fn main() { let a = c!(1,2,3,4); } 3.3 From ranges to Vector For R, there is seq to declare sequence. # R a = seq(1, 4, 1) print(a) # [1] 1 2 3 4 For peroxide, there is seq to declare sequence. fn main() { let a = seq(1, 4, 1); a.print(); // [1, 2, 3, 4] } 3.4 Vector Operation There are some vector-wise operations add(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; sub(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; mul(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; div(&amp;self, other: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; dot(&amp;self, other: Vec&lt;f64&gt;) -&gt; f64 norm(&amp;self) -&gt; f64 fn main() { let a = c!(1,2,3,4); let b = c!(4,3,2,1); a.add(&amp;b).print(); a.sub(&amp;b).print(); a.mul(&amp;b).print(); a.div(&amp;b).print(); a.dot(&amp;b).print(); a.norm().print(); // [5, 5, 5, 5] // [-3, -1, 1, 3] // [4, 6, 6, 4] // [0.25, 0.6667, 1.5, 4] // 20 // 5.477225575051661 // sqrt(30) } And there are some useful operations too. pow(&amp;self, usize) -&gt; Vec&lt;f64&gt; powf(&amp;self, f64) -&gt; Vec&lt;f64&gt; sqrt(&amp;self) -&gt; Vec&lt;f64&gt; fn main() { let a = c!(1,2,3,4); a.pow(2).print(); a.powf(0.5).print(); a.sqrt().print(); // [1, 4, 9, 16] // [1, 1.4142, 1.7321, 2] // [1, 1.4142, 1.7321, 2] } 3.5 Concatenation There are two concatenation operations. cat(T, Vec&lt;T&gt;) -&gt; Vec&lt;f64&gt; concat(Vec&lt;T&gt;, Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; fn main() { let a = c!(1,2,3,4); cat(0f64, a.clone()).print(); // [0, 1, 2, 3, 4] let b = c!(5,6,7,8); concat(a, b).print(); // [1, 2, 3, 4, 5, 6, 7, 8] } "],
["matrix.html", "4 Matrix 4.1 Declare matrix 4.2 Basic Method for Matrix 4.3 Read &amp; Write 4.4 Concatenation 4.5 Matrix operations 4.6 Extract &amp; modify components 4.7 Conversion between vector 4.8 Useful constructor", " 4 Matrix 4.1 Declare matrix You can declare matrix by various ways. R’s way - Default MATLAB’s way Python’s way Other macro 4.1.1 R’s way Description: Same as R - matrix(Vector, Row, Col, Shape) Type: matrix(Vec&lt;T&gt;, usize, usize, Shape) where T: std::convert::Into&lt;f64&gt; + Copy Shape: Enum for matrix shape - Row &amp; Col fn main() { let a = matrix(c!(1,2,3,4), 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 let b = matrix(c!(1,2,3,4), 2, 2, Col); b.print(); // c[0] c[1] // r[0] 1 3 // r[1] 2 4 } 4.1.2 MATLAB’s way Description: Similar to MATLAB (But should use &amp;str) Type: ml_matrix(&amp;str) fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.3 Python’s way Description: Declare matrix as vector of vectors. Type: py_matrix(Vec&lt;Vec&lt;T&gt;&gt;) where T: std::convert::Into&lt;f64&gt; + Copy fn main() { let a = py_matrix(vec![vec![1, 2], vec![3, 4]]); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.1.4 Other macro Description: R-like macro to declare matrix For R, # R a = matrix(1:4:1, 2, 2, Row) print(a) # [,1] [,2] # [1,] 1 2 # [2,] 3 4 For Peroxide, fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.2 Basic Method for Matrix There are some useful methods for Matrix row(&amp;self, index: usize) -&gt; Vec&lt;f64&gt; : Extract specific row as Vec&lt;f64&gt; col(&amp;self, index: usize) -&gt; Vec&lt;f64&gt; : Extract specific column as Vec&lt;f64&gt; diag(&amp;self) -&gt; Vec&lt;f64&gt;: Extract diagonal components as Vec&lt;f64&gt; swap(&amp;self, usize, usize, Shape) -&gt; Matrix: Swap two rows or columns subs_col(&amp;mut self, usize, Vec&lt;f64&gt;): Substitute column with Vec&lt;f64&gt; subs_row(&amp;mut self, usize, Vec&lt;f64&gt;): Substitute row with Vec&lt;f64&gt; fn main() { let a = ml_matrix(&quot;1 2; 3 4&quot;); a.row(0).print(); // [1, 2] a.col(0).print(); // [1, 3] a.diag().print(); // [1, 4] a.swap(0, 1, Row).print(); // c[0] c[1] // r[0] 3 4 // r[1] 1 2 let mut b = ml_matrix(&quot;1 2;3 4&quot;); b.subs_col(0, c!(5, 6)); b.subs_row(1, c!(7, 8)); b.print(); // c[0] c[1] // r[0] 5 2 // r[1] 7 8 } 4.3 Read &amp; Write In peroxide, we can write matrix to csv. write(&amp;self, file_path: &amp;str): Write matrix to csv write_with_header(&amp;self, file_path, header: Vec&lt;&amp;str&gt;): Write with header fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); a.write(&quot;matrix.csv&quot;).expect(&quot;Can&#39;t write file&quot;); let b = ml_matrix(&quot;1 2; 3 4; 5 6&quot;); b.write_with_header(&quot;header.csv&quot;, vec![&quot;odd&quot;, &quot;even&quot;]) .expect(&quot;Can&#39;t write header file&quot;); } Also, you can read matrix from csv. Type: read(&amp;str, bool, char) -&gt; Result&lt;Matrix, Box&lt;Error&gt;&gt; Description: read(file_path, is_header, delimiter) fn main() { let a = read(&quot;matrix.csv&quot;, false, &#39;,&#39;) .expect(&quot;Can&#39;t read matrix.csv file&quot;); a.print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 } 4.4 Concatenation There are two options to concatenate matrices. cbind: Concatenate two matrices by column direction. rbind: Concatenate two matrices by row direction. fn main() { let a = ml_matrix(&quot;1 2;3 4&quot;); let b = ml_matrix(&quot;5 6;7 8&quot;); cbind(a.clone(), b.clone()).print(); // c[0] c[1] c[2] c[3] // r[0] 1 2 5 7 // r[1] 3 4 6 8 rbind(a, b).print(); // c[0] c[1] // r[0] 1 2 // r[1] 3 4 // r[2] 5 6 // r[3] 7 8 } 4.5 Matrix operations In peroxide, can use basic operations between matrices. I’ll show you by examples. fn main() { let a = matrix!(1;4;1, 2, 2, Row); (a.clone() + 1).print(); // -, *, / are also available // c[0] c[1] // r[0] 2 3 // r[1] 4 5 let b = matrix!(5;8;1, 2, 2, Row); (a.clone() + b.clone()).print(); // -, *, / are also available // c[0] c[1] // r[0] 6 8 // r[1] 10 12 (a.clone() % b.clone()).print(); // Matrix multiplication // c[0] c[1] // r[0] 19 22 // r[1] 43 50 } 4.6 Extract &amp; modify components In peroxide, matrix data is saved as linear structure. But you can use two-dimensional index to extract or modify components. fn main() { let mut a = matrix!(1;4;1, 2, 2, Row); a[(0,0)].print(); // 1 a[(0,0)] = 2f64; // Modify component a.print(); // c[0] c[1] // r[0] 2 2 // r[1] 3 4 } 4.7 Conversion between vector 4.7.1 Vector to Matrix to_matrix method allows conversion from vector to column matrix. fn main() { let a = c!(1,2,3,4); a.to_matrix().print(); // c[0] // r[0] 1 // r[1] 2 // r[2] 3 // r[3] 4 } 4.7.2 Matrix to Vector Just use row or col method (I already showed at Basic method section). fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.row(0).print(); // [1, 2] } 4.8 Useful constructor zeros(usize, usize): Construct matrix which elements are all zero eye(usize): Identity matrix rand(usize, usize): Construct random uniform matrix (from 0 to 1) fn main() { let a = zeros(2, 2); assert_eq!(a, ml_matrix(&quot;0 0;0 0&quot;)); let b = eye(2); assert_eq!(b, ml_matrix(&quot;1 0;0 1&quot;)); let c = rand(2, 2); c.print(); // Random 2x2 matrix } "],
["linear.html", "5 Linear Algebra 5.1 Transpose 5.2 LU Decomposition 5.3 Determinant 5.4 Inverse matrix 5.5 Moore-Penrose Pseudo Inverse", " 5 Linear Algebra 5.1 Transpose Caution: Transpose does not consume the original value. fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.transpose().print(); // Or you can use shorter one a.t().print(); // c[0] c[1] // r[0] 1 3 // r[1] 2 4 } 5.2 LU Decomposition Peroxide uses complete pivoting for LU decomposition - Very stable Since there are lots of causes to generate error, you should use Option lu returns Option&lt;PQLU&gt; PQLU has four field - p, q, l , u p means row permutations q means column permutations l means lower triangular matrix u menas upper triangular matrix The structure of PQLU is as follows: #[derive(Debug, Clone)] pub struct PQLU { pub p: Perms, pub q: Perms, pub l: Matrix, pub u: Matrix, } pub type Perms = Vec&lt;(usize, usize)&gt;; Example of LU decomposition: fn main() { let a = matrix(c!(1,2,3,4), 2, 2, Row); let pqlu = a.lu().unwrap(); // unwrap because of Option let (p,q,l,u) = (pqlu.p, pqlu.q, pqlu.l, pqlu.u); assert_eq!(p, vec![(0,1)]); // swap 0 &amp; 1 (Row) assert_eq!(q, vec![(0,1)]); // swap 0 &amp; 1 (Col) assert_eq!(l, matrix(c!(1,0,0.5,1),2,2,Row)); // c[0] c[1] // r[0] 1 0 // r[1] 0.5 1 assert_eq!(u, matrix(c!(4,3,0,-0.5),2,2,Row)); // c[0] c[1] // r[0] 4 3 // r[1] 0 -0.5 } 5.3 Determinant Peroxide uses LU decomposition to obtain determinant (\\(\\mathcal{O}(n^3)\\)) fn main() { let a = matrix!(1;4;1, 2, 2, Row); assert_eq!(a.det(), -2f64); } 5.4 Inverse matrix Peroxide uses LU decomposition to obtain inverse matrix. It needs two sub functions - inv_l, inv_u For inverse of L, U, I use block partitioning. For example, for lower triangular matrix : \\[\\begin{aligned} L &amp;= \\begin{pmatrix} L_1 &amp; \\mathbf{0} \\\\ L_2 &amp; L_3 \\end{pmatrix} \\\\ L^{-1} &amp;= \\begin{pmatrix} L_1^{-1} &amp; \\mathbf{0} \\\\ -L_3^{-1}L_2 L_1^{-1} &amp; L_3^{-1} \\end{pmatrix} \\end{aligned} \\] fn main() { let a = matrix!(1;4;1, 2, 2, Row); a.inv().unwrap().print(); // c[0] c[1] // r[0] -2 1 // r[1] 1.5 -0.5 } 5.5 Moore-Penrose Pseudo Inverse \\(X^\\dagger = \\left(X^T X\\right)^{-1} X\\) fn main() { let a = matrix!(1;4;1, 2, 2, Row); let pinv_a = a.psudo_inv().unwrap(); let inv_a = a.inv().unwrap(); assert_eq!(inv_a, pinv_a); // Nearly equal (not actually equal) } // PartialEq implements impl PartialEq for Matrix { fn eq(&amp;self, other: &amp;Matrix) -&gt; bool { if self.shape == other.shape { self.data.clone() .into_iter() .zip(other.data.clone()) .all(|(x, y)| nearly_eq(x,y)) &amp;&amp; self.row == other.row } else { self.eq(&amp;other.change_shape()) } } } "],
["functional.html", "6 Functional Programming 6.1 FP for Vector 6.2 FP for Matrix", " 6 Functional Programming 6.1 FP for Vector There are some functional programming tools for Vec&lt;f64&gt; pub trait FPVector { type Scalar; fn fmap&lt;F&gt;(&amp;self, f: F) -&gt; Self where F: Fn(Self::Scalar) -&gt; Self::Scalar; fn reduce&lt;F, T&gt;(&amp;self, init: T, f: F) -&gt; Self::Scalar where F: Fn(Self::Scalar, Self::Scalar) -&gt; Self::Scalar, T: convert::Into&lt;Self::Scalar&gt;; fn zip_with&lt;F&gt;(&amp;self, f: F, other: &amp;Self) -&gt; Self where F: Fn(Self::Scalar, Self::Scalar) -&gt; Self::Scalar; fn filter&lt;F&gt;(&amp;self, f: F) -&gt; Self where F: Fn(Self::Scalar) -&gt; bool; fn take(&amp;self, n: usize) -&gt; Self; fn skip(&amp;self, n: usize) -&gt; Self; } 6.1.1 fmap fmap is syntactic sugar for map fn main() { let a = c!(1,2,3,4); // Original rust a.clone() .into_iter() .map(|x| x + 1f64) .collect::&lt;Vec&lt;f64&gt;&gt;() .print(); // [2, 3, 4, 5] // fmap in Peroxide a.fmap(|x| x + 1f64).print(); // [2, 3, 4, 5] } 6.1.2 reduce reduce is syntactic sugar for fold fn main() { let a = c!(1,2,3,4); // Original rust a.clone() .into_iter() .fold(0f64, |x, y| x + y) .print(); // 10 // reduce in Peroxide a.reduce(0f64, |x, y| x + y).print(); // 10 } 6.1.3 zip_with zip_with is composed of zip &amp; map fn main() { let a = c!(1,2,3,4); let b = c!(5,6,7,8); // Original rust a.clone() .into_iter() .zip(&amp;b) .map(|(x, y)| x + *y) .collect::&lt;Vec&lt;f64&gt;&gt;().print(); // [6, 8, 10, 12] // zip_with in Peroxide a.zip_with(|x, y| x + y, &amp;b).print(); // [6, 8, 10, 12] } 6.1.4 filter filter is just syntactic sugar for filter fn main() { let a = c!(1,2,3,4); a.filter(|x| x &gt; 2f64).print(); // [3, 4] } 6.1.5 take &amp; skip take is syntactic sugar for take fn main() { let a = c!(1,2,3,4); a.take(2).print(); // [1, 2] } skip is syntactic sugar for skip fn main() { let a = c!(1,2,3,4); a.skip(2).print(); // [3, 4] } 6.2 FP for Matrix Similar to FPVector pub trait FP { fn take(&amp;self, n: usize, shape: Shape) -&gt; Matrix; fn skip(&amp;self, n: usize, shape: Shape) -&gt; Matrix; fn fmap&lt;F&gt;(&amp;self, f: F) -&gt; Matrix where F: Fn(f64) -&gt; f64; fn reduce&lt;F, T&gt;(&amp;self, init: T, f: F) -&gt; f64 where F: Fn(f64, f64) -&gt; f64, T: convert::Into&lt;f64&gt;; fn zip_with&lt;F&gt;(&amp;self, f: F, other: &amp;Matrix) -&gt; Matrix where F: Fn(f64, f64) -&gt; f64; } Above functions play same roles as FPVector "],
["statistics.html", "7 Statistics 7.1 Statistics trait 7.2 Simple Random Number Generator 7.3 Probability Distribution", " 7 Statistics 7.1 Statistics trait To make generic code, there is Statistics trait mean: just mean var : variance sd : standard deviation (R-like notation) cov : covariance cor : correlation coefficient pub trait Statistics { type Array; type Value; fn mean(&amp;self) -&gt; Self::Value; fn var(&amp;self) -&gt; Self::Value; fn sd(&amp;self) -&gt; Self::Value; fn cov(&amp;self) -&gt; Self::Array; fn cor(&amp;self) -&gt; Self::Array; } 7.1.1 For Vec&lt;f64&gt; Caution: For Vec&lt;f64&gt;, cov &amp; cor are unimplemented (those for Matrix) fn main() { let a = c!(1,2,3,4,5); a.mean().print(); // 3 a.var().print(); // 2.5 a.sd().print(); // 1.5811388300841898 } But there are other functions to calculate cov &amp; cor fn main() { let v1 = c!(1,2,3); let v2 = c!(3,2,1); cov(&amp;v1, &amp;v2).print(); // -0.9999999999999998 cor(&amp;v1, &amp;v2).print(); // -0.9999999999999993 } 7.1.2 For Matrix For Matrix, mean, var, sd means column operations cov means covariance matrix &amp; cor means also correlation coefficient matrix fn main() { let m = matrix(c!(1,2,3,3,2,1), 3, 2, Col); m.mean().print(); // [2, 2] m.var().print(); // [1.0000, 1.0000] m.sd().print(); // [1.0000, 1.0000] m.cov().print(); // c[0] c[1] // r[0] 1.0000 -1.0000 // r[1] -1.0000 1.0000 m.cor().print(); // c[0] c[1] // r[0] 1 -1.0000 // r[1] -1.0000 1 } 7.2 Simple Random Number Generator Peroxide uses external rand crate to generate random number extern crate rand; use self::rand::prelude::*; fn main() { let mut rng = thread_rng(); let a = rng.gen_range(0f64, 1f64); // Generate random f64 number ranges from 0 to 1 } To want more detailed explanation, see rand crate 7.3 Probability Distribution There are some famous pdf in Peroxide (not checked pdfs will be implemented soon) Bernoulli Beta Dirichlet Gamma Normal Student’s t Uniform Wishart There are two enums to represent probability distribution OPDist&lt;T&gt; : One parameter distribution (Bernoulli) TPDist&lt;T&gt; : Two parameter distribution (Uniform, Normal, Beta, Gamma) T: PartialOrd + SampleUniform + Copy + Into&lt;f64&gt; There are some traits for pdf RNG trait - extract sample &amp; calculate pdf Statistics trait - already shown above 7.3.1 RNG trait RNG trait is composed of two fields sample: Extract samples pdf : Calculate pdf value at specific point pub trait RNG { /// Extract samples of distributions fn sample(&amp;self, n: usize) -&gt; Vec&lt;f64&gt;; /// Probability Distribution Function /// /// # Type /// `f64 -&gt; f64` fn pdf&lt;S: PartialOrd + SampleUniform + Copy + Into&lt;f64&gt;&gt;(&amp;self, x: S) -&gt; f64; } 7.3.2 Bernoulli Distribution Definition \\[\\text{Bern}(x | \\mu) = \\mu^x (1-\\mu)^{1-x}\\] Representative value Mean: \\(\\mu\\) Var : \\(\\mu(1 - \\mu)\\) In peroxide, to generate \\(\\text{Bern}(x | \\mu)\\), use simple algorithm Generate \\(U \\sim \\text{Unif}(0, 1)\\) If \\(U \\leq \\mu\\), then \\(X = 1\\) else \\(X = 0\\) Usage is very simple fn main() { let b = Bernoulli(0.1); // Bern(x | 0.1) b.sample(100).print(); // Generate 100 samples b.pdf(0).print(); // 0.9 b.mean().print(); // 0.1 b.var().print(); // 0.09 (approximately) b.sd().print(); // 0.3 (approximately) } 7.3.3 Uniform Distribution Definition \\[\\text{Unif}(x | a, b) = \\begin{cases} \\frac{1}{b - a} &amp; x \\in [a,b]\\\\ 0 &amp; \\text{otherwise} \\end{cases}\\] Representative value Mean: \\(\\frac{a + b}{2}\\) Var : \\(\\frac{1}{12}(b-a)^2\\) To generate uniform random number, Peroxide uses rand crate fn main() { let a = Unif(0, 1); a.sample(100).print(); a.pdf(0.2).print(); a.mean().print(); a.var().print(); a.sd().print(); } 7.3.4 Normal Distribution 7.3.5 Beta Distribution 7.3.6 Gamma Distribution "],
["references.html", "References", " References "]
]
